{
  "language": "Solidity",
  "sources": {
    "contracts/BountyPlatform.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n/**\r\n * @title BountyPlatform\r\n * @notice A Social-Fi bounty platform for Monad where companies post bounties,\r\n *         creators submit content, and the community votes with staked MON.\r\n *         Scoring: 60% company judge + 40% community votes.\r\n *         Reward split: 70% winner, 20% winning voters, 10% platform.\r\n */\r\ncontract BountyPlatform {\r\n    // =========================================================================\r\n    //                            REENTRANCY GUARD\r\n    // =========================================================================\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status = _NOT_ENTERED;\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    // =========================================================================\r\n    //                              DATA STRUCTURES\r\n    // =========================================================================\r\n\r\n    struct Bounty {\r\n        uint256 id;\r\n        address company;\r\n        string name;\r\n        string description;\r\n        uint256 deadline;\r\n        uint256 rewardPool;\r\n        bool isFinalized;\r\n        bool companyJudged;\r\n    }\r\n\r\n    struct CreatorEntry {\r\n        address creator;\r\n        string contentURI;       // IPFS hash or URL to submitted content\r\n        uint256 upvotes;\r\n        uint256 downvotes;\r\n        uint256 companyScore;    // 0-100, assigned by the bounty company\r\n        uint256 totalScore;      // Weighted final score (set on finalization)\r\n        bool rewardClaimed;\r\n    }\r\n\r\n    struct VoteStake {\r\n        uint256 amount;          // MON staked with this vote\r\n        address votedFor;        // Which creator received the vote\r\n        bool isUpvote;           // Was it an upvote or downvote\r\n        bool exists;             // Whether this voter has voted in this bounty\r\n    }\r\n\r\n    // =========================================================================\r\n    //                                 STATE\r\n    // =========================================================================\r\n\r\n    address public owner;                          // Platform owner (receives 10%)\r\n    uint256 public bountyCount;                    // Auto-incrementing bounty ID\r\n    uint256 public constant MIN_VOTE_STAKE = 0.01 ether; // Minimum stake per vote\r\n\r\n    /// @dev bountyId => Bounty\r\n    mapping(uint256 => Bounty) public bounties;\r\n\r\n    /// @dev bountyId => creator address => CreatorEntry\r\n    mapping(uint256 => mapping(address => CreatorEntry)) public creatorEntries;\r\n\r\n    /// @dev bountyId => ordered list of creator addresses\r\n    mapping(uint256 => address[]) public bountyCreators;\r\n\r\n    /// @dev bountyId => creator address => true if already joined\r\n    mapping(uint256 => mapping(address => bool)) public hasJoined;\r\n\r\n    /// @dev voter address => bountyId => VoteStake\r\n    mapping(address => mapping(uint256 => VoteStake)) public voteStakes;\r\n\r\n    /// @dev bountyId => total MON staked by all voters\r\n    mapping(uint256 => uint256) public totalStakedPerBounty;\r\n\r\n    /// @dev bountyId => winner address (set on finalization)\r\n    mapping(uint256 => address) public bountyWinner;\r\n\r\n    /// @dev bountyId => total stake placed on the winning creator\r\n    mapping(uint256 => uint256) public winnerTotalStake;\r\n\r\n    /// @dev bountyId => list of all voter addresses (for winner-stake computation)\r\n    mapping(uint256 => address[]) internal _bountyVoters;\r\n\r\n    /// @dev Track all bounty IDs for enumeration\r\n    uint256[] private allBountyIds;\r\n\r\n    // =========================================================================\r\n    //                                 EVENTS\r\n    // =========================================================================\r\n\r\n    event BountyCreated(\r\n        uint256 indexed bountyId,\r\n        address indexed company,\r\n        string name,\r\n        uint256 rewardPool,\r\n        uint256 deadline\r\n    );\r\n\r\n    event CreatorJoined(\r\n        uint256 indexed bountyId,\r\n        address indexed creator,\r\n        string contentURI\r\n    );\r\n\r\n    event VoteCast(\r\n        uint256 indexed bountyId,\r\n        address indexed voter,\r\n        address indexed creator,\r\n        bool isUpvote,\r\n        uint256 stakeAmount\r\n    );\r\n\r\n    event CompanyJudged(\r\n        uint256 indexed bountyId,\r\n        address indexed company\r\n    );\r\n\r\n    event BountyFinalized(\r\n        uint256 indexed bountyId,\r\n        address indexed winner,\r\n        uint256 winnerScore\r\n    );\r\n\r\n    event RewardClaimed(\r\n        uint256 indexed bountyId,\r\n        address indexed creator,\r\n        uint256 amount\r\n    );\r\n\r\n    event VoterRewardClaimed(\r\n        uint256 indexed bountyId,\r\n        address indexed voter,\r\n        uint256 amount\r\n    );\r\n\r\n    // =========================================================================\r\n    //                               MODIFIERS\r\n    // =========================================================================\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only platform owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCompany(uint256 bountyId) {\r\n        require(msg.sender == bounties[bountyId].company, \"Only bounty company\");\r\n        _;\r\n    }\r\n\r\n    modifier beforeDeadline(uint256 bountyId) {\r\n        require(block.timestamp < bounties[bountyId].deadline, \"Deadline has passed\");\r\n        _;\r\n    }\r\n\r\n    modifier afterDeadline(uint256 bountyId) {\r\n        require(block.timestamp >= bounties[bountyId].deadline, \"Deadline not reached\");\r\n        _;\r\n    }\r\n\r\n    modifier notFinalized(uint256 bountyId) {\r\n        require(!bounties[bountyId].isFinalized, \"Bounty already finalized\");\r\n        _;\r\n    }\r\n\r\n    // =========================================================================\r\n    //                              CONSTRUCTOR\r\n    // =========================================================================\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // =========================================================================\r\n    //                           CORE FUNCTIONS\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @notice Create a new bounty. The sent MON becomes the reward pool.\r\n     * @param _name        Short title for the bounty\r\n     * @param _description Detailed description of what creators should produce\r\n     * @param _deadline    Unix timestamp after which submissions and votes close\r\n     */\r\n    function createBounty(\r\n        string calldata _name,\r\n        string calldata _description,\r\n        uint256 _deadline\r\n    ) external payable {\r\n        require(msg.value > 0, \"Reward pool must be > 0\");\r\n        require(_deadline > block.timestamp, \"Deadline must be in the future\");\r\n        require(bytes(_name).length > 0, \"Name cannot be empty\");\r\n\r\n        uint256 bountyId = bountyCount;\r\n        bountyCount++;\r\n\r\n        bounties[bountyId] = Bounty({\r\n            id: bountyId,\r\n            company: msg.sender,\r\n            name: _name,\r\n            description: _description,\r\n            deadline: _deadline,\r\n            rewardPool: msg.value,\r\n            isFinalized: false,\r\n            companyJudged: false\r\n        });\r\n\r\n        allBountyIds.push(bountyId);\r\n\r\n        emit BountyCreated(bountyId, msg.sender, _name, msg.value, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @notice Join a bounty by submitting content.\r\n     * @param bountyId   The bounty to join\r\n     * @param contentURI IPFS hash or URL pointing to the creator's submission\r\n     */\r\n    function joinBounty(\r\n        uint256 bountyId,\r\n        string calldata contentURI\r\n    ) external beforeDeadline(bountyId) notFinalized(bountyId) {\r\n        require(bountyId < bountyCount, \"Bounty does not exist\");\r\n        require(!hasJoined[bountyId][msg.sender], \"Already joined this bounty\");\r\n        require(bytes(contentURI).length > 0, \"Content URI cannot be empty\");\r\n        require(msg.sender != bounties[bountyId].company, \"Company cannot join own bounty\");\r\n\r\n        hasJoined[bountyId][msg.sender] = true;\r\n\r\n        creatorEntries[bountyId][msg.sender] = CreatorEntry({\r\n            creator: msg.sender,\r\n            contentURI: contentURI,\r\n            upvotes: 0,\r\n            downvotes: 0,\r\n            companyScore: 0,\r\n            totalScore: 0,\r\n            rewardClaimed: false\r\n        });\r\n\r\n        bountyCreators[bountyId].push(msg.sender);\r\n\r\n        emit CreatorJoined(bountyId, msg.sender, contentURI);\r\n    }\r\n\r\n    /**\r\n     * @notice Vote on a creator's submission by staking MON.\r\n     *         Each wallet gets exactly one vote per bounty (up or down on one creator).\r\n     * @param bountyId The bounty context\r\n     * @param creator  The creator to vote on\r\n     * @param isUpvote true = upvote, false = downvote\r\n     */\r\n    function vote(\r\n        uint256 bountyId,\r\n        address creator,\r\n        bool isUpvote\r\n    ) external payable beforeDeadline(bountyId) notFinalized(bountyId) {\r\n        require(bountyId < bountyCount, \"Bounty does not exist\");\r\n        require(msg.value >= MIN_VOTE_STAKE, \"Stake below minimum (0.01 MON)\");\r\n        require(hasJoined[bountyId][creator], \"Creator not in this bounty\");\r\n        require(!voteStakes[msg.sender][bountyId].exists, \"Already voted in this bounty\");\r\n        require(msg.sender != creator, \"Cannot vote for yourself\");\r\n\r\n        // Record the vote stake\r\n        voteStakes[msg.sender][bountyId] = VoteStake({\r\n            amount: msg.value,\r\n            votedFor: creator,\r\n            isUpvote: isUpvote,\r\n            exists: true\r\n        });\r\n\r\n        totalStakedPerBounty[bountyId] += msg.value;\r\n\r\n        // Track voter address for winner-stake computation at finalization\r\n        _bountyVoters[bountyId].push(msg.sender);\r\n\r\n        // Update creator vote tallies\r\n        if (isUpvote) {\r\n            creatorEntries[bountyId][creator].upvotes++;\r\n        } else {\r\n            creatorEntries[bountyId][creator].downvotes++;\r\n        }\r\n\r\n        emit VoteCast(bountyId, msg.sender, creator, isUpvote, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Company scores each creator 0-100. Can only be called once per bounty.\r\n     * @param bountyId The bounty to judge\r\n     * @param creators Array of creator addresses to score\r\n     * @param scores   Corresponding scores (0-100) for each creator\r\n     */\r\n    function companyJudge(\r\n        uint256 bountyId,\r\n        address[] calldata creators,\r\n        uint256[] calldata scores\r\n    ) external onlyCompany(bountyId) notFinalized(bountyId) {\r\n        require(bountyId < bountyCount, \"Bounty does not exist\");\r\n        require(!bounties[bountyId].companyJudged, \"Already judged\");\r\n        require(creators.length == scores.length, \"Arrays length mismatch\");\r\n        require(creators.length > 0, \"Must score at least one creator\");\r\n\r\n        for (uint256 i = 0; i < creators.length; i++) {\r\n            require(hasJoined[bountyId][creators[i]], \"Creator not in this bounty\");\r\n            require(scores[i] <= 100, \"Score must be 0-100\");\r\n            creatorEntries[bountyId][creators[i]].companyScore = scores[i];\r\n        }\r\n\r\n        bounties[bountyId].companyJudged = true;\r\n\r\n        emit CompanyJudged(bountyId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Finalize the bounty: compute final scores, determine winner, pay platform fee.\r\n     *         Anyone can call after deadline + company has judged.\r\n     * @param bountyId The bounty to finalize\r\n     */\r\n    function finalizeBounty(\r\n        uint256 bountyId\r\n    ) external afterDeadline(bountyId) notFinalized(bountyId) nonReentrant {\r\n        require(bountyId < bountyCount, \"Bounty does not exist\");\r\n        require(bounties[bountyId].companyJudged, \"Company has not judged yet\");\r\n\r\n        address[] storage creators = bountyCreators[bountyId];\r\n        require(creators.length > 0, \"No creators in this bounty\");\r\n\r\n        address winner = address(0);\r\n        uint256 highestScore = 0;\r\n\r\n        for (uint256 i = 0; i < creators.length; i++) {\r\n            CreatorEntry storage entry = creatorEntries[bountyId][creators[i]];\r\n\r\n            // Calculate community score: upvotes as percentage of total votes\r\n            uint256 communityScore;\r\n            uint256 totalVotes = entry.upvotes + entry.downvotes;\r\n            if (totalVotes == 0) {\r\n                communityScore = 0; // No votes => 0 community score\r\n            } else {\r\n                communityScore = (entry.upvotes * 100) / totalVotes;\r\n            }\r\n\r\n            // Weighted total: 60% company + 40% community\r\n            uint256 finalScore = (entry.companyScore * 60) / 100\r\n                               + (communityScore * 40) / 100;\r\n\r\n            entry.totalScore = finalScore;\r\n\r\n            if (finalScore > highestScore) {\r\n                highestScore = finalScore;\r\n                winner = creators[i];\r\n            }\r\n        }\r\n\r\n        require(winner != address(0), \"No valid winner\");\r\n\r\n        bounties[bountyId].isFinalized = true;\r\n        bountyWinner[bountyId] = winner;\r\n\r\n        // Winner total stake is computed lazily on first voter claim to save gas here.\r\n        // _computeWinnerTotalStake() is called in claimVoterReward if not yet set.\r\n\r\n        // Transfer 10% platform fee to contract owner\r\n        uint256 platformFee = (bounties[bountyId].rewardPool * 10) / 100;\r\n        if (platformFee > 0) {\r\n            (bool success, ) = owner.call{value: platformFee}(\"\");\r\n            require(success, \"Platform fee transfer failed\");\r\n        }\r\n\r\n        emit BountyFinalized(bountyId, winner, highestScore);\r\n    }\r\n\r\n    /**\r\n     * @notice Winner claims 70% of the reward pool.\r\n     * @param bountyId The finalized bounty\r\n     */\r\n    function claimCreatorReward(uint256 bountyId) external nonReentrant {\r\n        require(bounties[bountyId].isFinalized, \"Bounty not finalized\");\r\n        require(bountyWinner[bountyId] == msg.sender, \"Only the winner can claim\");\r\n\r\n        CreatorEntry storage entry = creatorEntries[bountyId][msg.sender];\r\n        require(!entry.rewardClaimed, \"Reward already claimed\");\r\n\r\n        entry.rewardClaimed = true;\r\n\r\n        uint256 creatorReward = (bounties[bountyId].rewardPool * 70) / 100;\r\n\r\n        (bool success, ) = msg.sender.call{value: creatorReward}(\"\");\r\n        require(success, \"Creator reward transfer failed\");\r\n\r\n        emit RewardClaimed(bountyId, msg.sender, creatorReward);\r\n    }\r\n\r\n    /**\r\n     * @notice Voters claim their stake back. If they voted for the winner, they also\r\n     *         receive a proportional share of 20% of the reward pool.\r\n     * @param bountyId The finalized bounty\r\n     */\r\n    function claimVoterReward(uint256 bountyId) external nonReentrant {\r\n        require(bounties[bountyId].isFinalized, \"Bounty not finalized\");\r\n\r\n        VoteStake storage stake = voteStakes[msg.sender][bountyId];\r\n        require(stake.exists, \"No vote stake found\");\r\n        require(stake.amount > 0, \"Already claimed\");\r\n\r\n        uint256 stakeAmount = stake.amount;\r\n        address votedFor = stake.votedFor;\r\n\r\n        // Zero out stake before transfer to prevent reentrancy\r\n        stake.amount = 0;\r\n\r\n        uint256 payout = stakeAmount; // At minimum, voters get their stake back\r\n\r\n        if (votedFor == bountyWinner[bountyId] && stake.isUpvote) {\r\n            // Voter backed the winner — they share 20% of the reward pool\r\n            // Proportional to their stake among all winner-backing stakes\r\n            uint256 voterRewardPool = (bounties[bountyId].rewardPool * 20) / 100;\r\n\r\n            // We need the total stake on the winner. Compute it if not yet set.\r\n            if (winnerTotalStake[bountyId] == 0) {\r\n                _computeWinnerTotalStake(bountyId);\r\n            }\r\n\r\n            if (winnerTotalStake[bountyId] > 0) {\r\n                uint256 voterShare = (voterRewardPool * stakeAmount) / winnerTotalStake[bountyId];\r\n                payout += voterShare;\r\n            }\r\n        }\r\n\r\n        (bool success, ) = msg.sender.call{value: payout}(\"\");\r\n        require(success, \"Voter reward transfer failed\");\r\n\r\n        emit VoterRewardClaimed(bountyId, msg.sender, payout);\r\n    }\r\n\r\n    // =========================================================================\r\n    //                            VIEW FUNCTIONS\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @notice Get the full leaderboard for a bounty.\r\n     * @param bountyId The bounty to query\r\n     * @return creators_    Array of creator addresses\r\n     * @return contentURIs  Array of content URIs\r\n     * @return upvotes_     Array of upvote counts\r\n     * @return downvotes_   Array of downvote counts\r\n     * @return companyScores Array of company-assigned scores\r\n     * @return totalScores  Array of weighted final scores (0 until finalized)\r\n     */\r\n    function getLeaderboard(uint256 bountyId)\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory creators_,\r\n            string[] memory contentURIs,\r\n            uint256[] memory upvotes_,\r\n            uint256[] memory downvotes_,\r\n            uint256[] memory companyScores,\r\n            uint256[] memory totalScores\r\n        )\r\n    {\r\n        address[] storage _creators = bountyCreators[bountyId];\r\n        uint256 len = _creators.length;\r\n\r\n        creators_ = new address[](len);\r\n        contentURIs = new string[](len);\r\n        upvotes_ = new uint256[](len);\r\n        downvotes_ = new uint256[](len);\r\n        companyScores = new uint256[](len);\r\n        totalScores = new uint256[](len);\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            CreatorEntry storage entry = creatorEntries[bountyId][_creators[i]];\r\n            creators_[i] = entry.creator;\r\n            contentURIs[i] = entry.contentURI;\r\n            upvotes_[i] = entry.upvotes;\r\n            downvotes_[i] = entry.downvotes;\r\n            companyScores[i] = entry.companyScore;\r\n            totalScores[i] = entry.totalScore;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the list of creator addresses for a bounty.\r\n     * @param bountyId The bounty to query\r\n     * @return Array of creator addresses\r\n     */\r\n    function getBountyCreators(uint256 bountyId)\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return bountyCreators[bountyId];\r\n    }\r\n\r\n    /**\r\n     * @notice Get all active (not finalized, deadline not passed) bounty IDs.\r\n     * @return activeIds Array of active bounty IDs\r\n     */\r\n    function getActiveBounties()\r\n        external\r\n        view\r\n        returns (uint256[] memory activeIds)\r\n    {\r\n        // First pass: count active bounties\r\n        uint256 activeCount = 0;\r\n        for (uint256 i = 0; i < allBountyIds.length; i++) {\r\n            uint256 bid = allBountyIds[i];\r\n            if (!bounties[bid].isFinalized && block.timestamp < bounties[bid].deadline) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        // Second pass: populate array\r\n        activeIds = new uint256[](activeCount);\r\n        uint256 idx = 0;\r\n        for (uint256 i = 0; i < allBountyIds.length; i++) {\r\n            uint256 bid = allBountyIds[i];\r\n            if (!bounties[bid].isFinalized && block.timestamp < bounties[bid].deadline) {\r\n                activeIds[idx] = bid;\r\n                idx++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get full details of a specific bounty.\r\n     * @param bountyId The bounty to query\r\n     */\r\n    function getBounty(uint256 bountyId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 id,\r\n            address company,\r\n            string memory name,\r\n            string memory description,\r\n            uint256 deadline,\r\n            uint256 rewardPool,\r\n            bool isFinalized,\r\n            bool companyJudged,\r\n            address winner\r\n        )\r\n    {\r\n        Bounty storage b = bounties[bountyId];\r\n        return (\r\n            b.id,\r\n            b.company,\r\n            b.name,\r\n            b.description,\r\n            b.deadline,\r\n            b.rewardPool,\r\n            b.isFinalized,\r\n            b.companyJudged,\r\n            bountyWinner[bountyId]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get a voter's stake info for a specific bounty.\r\n     * @param voter   The voter address\r\n     * @param bountyId The bounty to query\r\n     */\r\n    function getVoteInfo(address voter, uint256 bountyId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            address votedFor,\r\n            bool isUpvote,\r\n            bool exists\r\n        )\r\n    {\r\n        VoteStake storage vs = voteStakes[voter][bountyId];\r\n        return (vs.amount, vs.votedFor, vs.isUpvote, vs.exists);\r\n    }\r\n\r\n    // =========================================================================\r\n    //                          INTERNAL HELPERS\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @dev Compute the total stake placed by upvoters on the winning creator.\r\n     *      This is called lazily on the first voter claim to save gas at finalization.\r\n     *      NOTE: This iterates all creators' upvoters — in a production system with\r\n     *      many voters you would want an off-chain indexer or accumulate during voting.\r\n     *      For hackathon scope with bounded participants, this is acceptable.\r\n     */\r\n    function _computeWinnerTotalStake(uint256 bountyId) internal {\r\n        address[] storage voters = _bountyVoters[bountyId];\r\n        address winner = bountyWinner[bountyId];\r\n        uint256 total = 0;\r\n\r\n        for (uint256 i = 0; i < voters.length; i++) {\r\n            VoteStake storage vs = voteStakes[voters[i]][bountyId];\r\n            if (vs.votedFor == winner && vs.isUpvote) {\r\n                total += vs.amount;\r\n            }\r\n        }\r\n\r\n        winnerTotalStake[bountyId] = total;\r\n    }\r\n\r\n    // =========================================================================\r\n    //                     TRANSFER OWNERSHIP (PLATFORM)\r\n    // =========================================================================\r\n\r\n    /**\r\n     * @notice Transfer platform ownership.\r\n     * @param newOwner The new platform owner address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"New owner is zero address\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Emergency withdrawal for unclaimed funds after a long period.\r\n     *         Only callable by the platform owner.\r\n     * @param amount The amount to withdraw\r\n     */\r\n    function emergencyWithdraw(uint256 amount) external onlyOwner nonReentrant {\r\n        require(amount <= address(this).balance, \"Insufficient balance\");\r\n        (bool success, ) = owner.call{value: amount}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n    }\r\n\r\n    /// @notice Allow contract to receive MON directly\r\n    receive() external payable {}\r\n}\r\n"
    }
  },
  "settings": {
    "viaIR": true,
    "evmVersion": "prague",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}